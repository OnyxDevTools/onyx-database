// filename: gen/emit.ts
export type OnyxAttributeType =
  | 'String'
  | 'Int'
  | 'Boolean'
  | 'Timestamp'
  | 'EmbeddedList'
  | 'EmbeddedObject';

export type OnyxAttribute = Readonly<{
  name: string;
  type: OnyxAttributeType;
  isNullable: boolean;
}>;

export type OnyxTable = Readonly<{
  name: string;
  attributes: readonly OnyxAttribute[];
}>;

export type OnyxIntrospection = Readonly<{
  tables: readonly OnyxTable[];
}>;

export type OptionalStrategy = 'non-null' | 'nullable' | 'none';

export type EmitOptions = Readonly<{
  /** Exported schema mapping type name. */
  schemaTypeName?: string;
  /** How to represent Timestamp attributes. Default: 'string'. */
  timestampMode?: 'string' | 'date' | 'number';
  /** Prefix added to each generated model/interface name. Example: 'Onyx' -> OnyxVodItem */
  modelNamePrefix?: string;
  /**
   * Where to use the TypeScript optional property modifier `?`.
   *  - 'non-null' (default): add `?` on non-nullable fields (isNullable === false)
   *  - 'nullable'          : add `?` on nullable fields (isNullable === true)
   *  - 'none'              : never add `?`
   */
  optionalStrategy?: OptionalStrategy;
}>;

const DEFAULTS: Required<EmitOptions> = {
  schemaTypeName: 'OnyxSchema',
  timestampMode: 'string',
  modelNamePrefix: '',
  optionalStrategy: 'non-null',
};

function isValidIdentifier(name: string): boolean {
  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);
}

function toPascalCase(raw: string): string {
  const cleaned = String(raw).replace(/[^A-Za-z0-9]+/g, ' ');
  const pc = cleaned
    .trim()
    .split(/\s+/)
    .filter(Boolean)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');
  return pc.length === 0 ? 'Table' : (/^[0-9]/.test(pc) ? `T${pc}` : pc);
}

function tsTypeFor(
  attrType: OnyxAttributeType,
  timestampMode: 'string' | 'date' | 'number',
): string {
  switch (attrType) {
    case 'String':
      return 'string';
    case 'Int':
      return 'number';
    case 'Boolean':
      return 'boolean';
    case 'Timestamp':
      return timestampMode === 'date'
        ? 'Date'
        : timestampMode === 'number'
        ? 'number'
        : 'string';
    case 'EmbeddedList':
      return 'any[]';
    case 'EmbeddedObject':
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

function propertyLine(
  attr: OnyxAttribute,
  timestampMode: 'string' | 'date' | 'number',
  optionalStrategy: OptionalStrategy,
): string {
  const key = isValidIdentifier(attr.name) ? attr.name : JSON.stringify(attr.name);

  // Decide whether to mark the property as optional (with '?')
  const makeOptional =
    optionalStrategy === 'non-null'
      ? !attr.isNullable
      : optionalStrategy === 'nullable'
      ? attr.isNullable
      : false;

  const t = tsTypeFor(attr.type, timestampMode);
  const nullableUnion = attr.isNullable ? ' | null' : '';

  return `  ${key}${makeOptional ? '?' : ''}: ${t}${nullableUnion};`;
}

export function emitTypes(schema: OnyxIntrospection, options?: EmitOptions): string {
  const opts = { ...DEFAULTS, ...(options ?? {}) };

  // Track used enum keys to avoid collisions
  const usedEnumKeys = new Set<string>();
  const makeEnumKey = (raw: string): string => {
    const base = toPascalCase(raw);
    let key = base;
    let i = 2;
    while (usedEnumKeys.has(key)) {
      key = `${base}_${i++}`;
    }
    usedEnumKeys.add(key);
    return key;
  };

  const lines: string[] = [];
  lines.push(`// AUTO-GENERATED BY onyx-gen. DO NOT EDIT.`);
  lines.push(`// Generated at ${new Date().toISOString()}`);
  lines.push('');

  // Per-table interfaces
  for (const t of schema.tables) {
    const typeName = `${opts.modelNamePrefix}${toPascalCase(t.name)}`;
    lines.push(`export interface ${typeName} {`);
    for (const a of t.attributes) {
      lines.push(propertyLine(a, opts.timestampMode, opts.optionalStrategy));
    }
    lines.push('}');
    lines.push('');
  }

  // Schema mapping
  lines.push(`export type ${opts.schemaTypeName} = {`);
  for (const t of schema.tables) {
    const key = isValidIdentifier(t.name) ? t.name : JSON.stringify(t.name);
    const modelName = `${opts.modelNamePrefix}${toPascalCase(t.name)}`;
    lines.push(`  ${key}: ${modelName};`);
  }
  lines.push('};');
  lines.push('');

  // Convenience alias so consumers can always `import { Schema }`
  if (opts.schemaTypeName !== 'Schema') {
    lines.push(`export type Schema = ${opts.schemaTypeName};`);
    lines.push('');
  }

  // Tables enum (for IDE suggestions & safer table refs)
  lines.push('export enum tables {');
  for (const t of schema.tables) {
    const enumKey = makeEnumKey(t.name); // safe TS identifier
    const enumVal = JSON.stringify(t.name); // preserve original table name
    lines.push(`  ${enumKey} = ${enumVal},`);
  }
  lines.push('}');
  lines.push('');

  return lines.join('\n');
}
